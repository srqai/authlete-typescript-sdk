/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

export type AuthTokenCreateApiRequestBody = {
  /**
   * The grant type of the access token when the access token was created.
   *
   * @remarks
   */
  grantType: models.GrantType;
  /**
   * The ID of the client application which will be associated with a newly created access token.
   *
   * @remarks
   */
  clientId: number;
  /**
   * The subject (= unique identifier) of the user who will be associated with a newly created access
   *
   * @remarks
   * token. This parameter is required unless the grant type is `CLIENT_CREDENTIALS`. The value must
   * consist of only ASCII characters and its length must not exceed 100.
   */
  subject?: string | undefined;
  /**
   * The scopes which will be associated with a newly created access token. Scopes that are not supported
   *
   * @remarks
   * by the service cannot be specified and requesting them will cause an error.
   */
  scopes?: Array<string> | undefined;
  /**
   * The duration of a newly created access token in seconds. If the value is 0, the duration is determined
   *
   * @remarks
   * according to the settings of the service.
   */
  accessTokenDuration?: number | undefined;
  /**
   * The duration of a newly created refresh token in seconds. If the value is 0, the duration is
   *
   * @remarks
   * determined according to the settings of the service.
   *
   * A refresh token is not created (1) if the service does not support `REFRESH_TOKEN`, or (2) if the
   * specified grant type is either `IMPLICIT`or `CLIENT_CREDENTIALS`.
   */
  refreshTokenDuration?: number | undefined;
  /**
   * Extra properties to associate with a newly created access token. Note that properties parameter
   *
   * @remarks
   * is accepted only when the HTTP method of the request is POST and Content-Type of the request is
   * `application/json`, so don't use `GET` method or `application/x-www-form-urlencoded` if you want
   * to specify properties.
   */
  properties?: Array<models.Property> | undefined;
  /**
   * A boolean request parameter which indicates whether to emulate that the client ID alias is used
   *
   * @remarks
   * instead of the original numeric client ID when a new access token is created.
   *
   * This has an effect only on the value of the aud claim in a response from [UserInfo endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo).
   * When you access the UserInfo endpoint (which is expected to be implemented using Authlete's
   * `/api/auth/userinfo` API and `/api/auth/userinfo/issue` API) with an access token which has been
   * created using Authlete's `/api/auth/token/create` API with this property (`clientIdAliasUsed`)
   * `true`, the client ID alias is used as the value of the aud claim in a response from the UserInfo
   * endpoint.
   *
   * Note that if a client ID alias is not assigned to the client when Authlete's `/api/auth/token/create`
   * API is called, this property (`clientIdAliasUsed`) has no effect (it is always regarded as `false`).
   */
  clientIdAliasUsed?: boolean | undefined;
  /**
   * The value of the new access token.
   *
   * @remarks
   *
   * The `/api/auth/token/create` API generates an access token. Therefore, callers of the API do not
   * have to specify values of newly created access tokens. However, in some cases, for example, if
   * you want to migrate existing access tokens from an old system to Authlete, you may want to specify
   * values of access tokens. In such a case, you can specify the value of a newly created access token
   * by passing a non-null value as the value of accessToken request parameter. The implementation
   * of the `/api/auth/token/create` uses the value of the accessToken request parameter instead of
   * generating a new value when the request parameter holds a non-null value.
   *
   * Note that if the hash value of the specified access token already exists in Authlete's database,
   * the access token cannot be inserted and the `/api/auth/token/create` API will report an error.
   */
  accessToken?: string | undefined;
  /**
   * The value of the new refresh token.
   *
   * @remarks
   *
   * The `/api/auth/token/create` API may generate a refresh token. Therefore, callers of the API do
   * not have to specify values of newly created refresh tokens. However, in some cases, for example,
   * if you want to migrate existing refresh tokens from an old system to Authlete, you may want to
   * specify values of refresh tokens. In such a case, you can specify the value of a newly created
   * refresh token by passing a non-null value as the value of refreshToken request parameter. The
   * implementation of the `/api/auth/token/create` uses the value of the refreshToken request parameter
   * instead of generating a new value when the request parameter holds a non-null value.
   *
   * Note that if the hash value of the specified refresh token already exists in Authlete's database,
   * the refresh token cannot be inserted and the `/api/auth/token/create` API will report an error.
   */
  refreshToken?: string | undefined;
  /**
   * Get whether the access token expires or not. By default, all access tokens expire after a period
   *
   * @remarks
   * of time determined by their service.
   *
   * If this request parameter is `true`, then the access token will not automatically expire and must
   * be revoked or deleted manually at the service. If this request parameter is true, the `accessTokenDuration`
   * request parameter is ignored.
   */
  accessTokenPersistent?: boolean | undefined;
  /**
   * The thumbprint of the MTLS certificate bound to this token. If this property is set, a certificate
   *
   * @remarks
   * with the corresponding value MUST be presented with the access token when it is used by a client.
   * The value of this property must be a SHA256 certificate thumbprint, base64url encoded.
   */
  certificateThumbprint?: string | undefined;
  /**
   * The thumbprint of the public key used for DPoP presentation of this token. If this property is
   *
   * @remarks
   * set, a DPoP proof signed with the corresponding private key MUST be presented with the access
   * token when it is used by a client. Additionally, the token's `token_type` will be set to 'DPoP'.
   */
  dpopKeyThumbprint?: string | undefined;
  /**
   * The authorization details. This represents the value of the `authorization_details`
   *
   * @remarks
   * request parameter in the preceding device authorization request which is defined in
   * "OAuth 2.0 Rich Authorization Requests".
   */
  authorizationDetails?: models.AuthorizationDetails | undefined;
  /**
   * The value of the resources to associate with the token. This property represents the value of
   *
   * @remarks
   * one or more `resource` request parameters which is defined in "RFC8707 Resource Indicators for
   * OAuth 2.0".
   */
  resources?: Array<string> | undefined;
  /**
   * the flag which indicates whether the access token is for an external
   *
   * @remarks
   * attachment.
   */
  forExternalAttachment?: boolean | undefined;
  /**
   * Additional claims that are added to the payload part of the JWT access token.
   *
   * @remarks
   */
  jwtAtClaims?: string | undefined;
  /**
   * The Authentication Context Class Reference of the user authentication that the authorization server performed
   *
   * @remarks
   * during the course of issuing the access token.
   */
  acr?: string | undefined;
  /**
   * The time when the user authentication was performed during the course of issuing the access token.
   *
   * @remarks
   */
  authTime?: number | undefined;
  /**
   * Flag which indicates whether the entity ID of the client was used when the request for the access token was made.
   *
   * @remarks
   */
  clientEntityIdUsed?: boolean | undefined;
};

export type AuthTokenCreateApiRequest = {
  /**
   * A service ID.
   */
  serviceId: string;
  requestBody: AuthTokenCreateApiRequestBody;
};

/**
 * The next action that the authorization server implementation should take.
 */
export const AuthTokenCreateApiAction = {
  InternalServerError: "INTERNAL_SERVER_ERROR",
  BadRequest: "BAD_REQUEST",
  Forbidden: "FORBIDDEN",
  Ok: "OK",
} as const;
/**
 * The next action that the authorization server implementation should take.
 */
export type AuthTokenCreateApiAction = ClosedEnum<
  typeof AuthTokenCreateApiAction
>;

export type AuthTokenCreateApiResponse = {
  /**
   * The code which represents the result of the API call.
   */
  resultCode?: string | undefined;
  /**
   * A short message which explains the result of the API call.
   */
  resultMessage?: string | undefined;
  /**
   * The next action that the authorization server implementation should take.
   */
  action?: AuthTokenCreateApiAction | undefined;
  /**
   * The newly issued access token.
   */
  accessToken?: string | undefined;
  /**
   * The ID of the client application associated with the access token.
   *
   * @remarks
   */
  clientId?: number | undefined;
  /**
   * The time at which the access token expires.
   *
   * @remarks
   */
  expiresAt?: number | undefined;
  /**
   * The duration of the newly issued access token in seconds.
   *
   * @remarks
   */
  expiresIn?: number | undefined;
  /**
   * The grant type for the newly issued access token.
   *
   * @remarks
   */
  grantType?: string | undefined;
  /**
   * The extra properties associated with the access token.
   *
   * @remarks
   */
  properties?: Array<models.Property> | undefined;
  /**
   * The newly issued refresh token.
   *
   * @remarks
   */
  refreshToken?: string | undefined;
  /**
   * Scopes which are associated with the access token.
   *
   * @remarks
   */
  scopes?: Array<string> | undefined;
  /**
   * The subject (= unique identifier) of the user associated with the newly issued access
   *
   * @remarks
   * token.
   */
  subject?: string | undefined;
  /**
   * The token type of the access token.
   *
   * @remarks
   */
  tokenType?: string | undefined;
  /**
   * If the authorization server is configured to issue JWT-based access tokens (= if `Service.accessTokenSignAlg`
   *
   * @remarks
   * is set to a `non-null` value), a JWT-based access token is issued along with the original
   * random-string one.
   */
  jwtAccessToken?: string | undefined;
  /**
   * The authorization details. This represents the value of the `authorization_details`
   *
   * @remarks
   * request parameter in the preceding device authorization request which is defined in
   * "OAuth 2.0 Rich Authorization Requests".
   */
  authorizationDetails?: models.AuthorizationDetails | undefined;
  /**
   * the flag which indicates whether the access token is for an external
   *
   * @remarks
   * attachment.
   */
  forExternalAttachment?: boolean | undefined;
  /**
   * Set the unique token identifier.
   *
   * @remarks
   */
  tokenId?: string | undefined;
  /**
   * The scopes associated with the refresh token. May be null.
   *
   * @remarks
   */
  refreshTokenScopes?: Array<string> | undefined;
};

/** @internal */
export const AuthTokenCreateApiRequestBody$inboundSchema: z.ZodType<
  AuthTokenCreateApiRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  grantType: models.GrantType$inboundSchema,
  clientId: z.number().int(),
  subject: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  accessTokenDuration: z.number().int().optional(),
  refreshTokenDuration: z.number().int().optional(),
  properties: z.array(models.Property$inboundSchema).optional(),
  clientIdAliasUsed: z.boolean().optional(),
  accessToken: z.string().optional(),
  refreshToken: z.string().optional(),
  accessTokenPersistent: z.boolean().optional(),
  certificateThumbprint: z.string().optional(),
  dpopKeyThumbprint: z.string().optional(),
  authorizationDetails: models.AuthorizationDetails$inboundSchema.optional(),
  resources: z.array(z.string()).optional(),
  forExternalAttachment: z.boolean().optional(),
  jwtAtClaims: z.string().optional(),
  acr: z.string().optional(),
  authTime: z.number().int().optional(),
  clientEntityIdUsed: z.boolean().optional(),
});

/** @internal */
export type AuthTokenCreateApiRequestBody$Outbound = {
  grantType: string;
  clientId: number;
  subject?: string | undefined;
  scopes?: Array<string> | undefined;
  accessTokenDuration?: number | undefined;
  refreshTokenDuration?: number | undefined;
  properties?: Array<models.Property$Outbound> | undefined;
  clientIdAliasUsed?: boolean | undefined;
  accessToken?: string | undefined;
  refreshToken?: string | undefined;
  accessTokenPersistent?: boolean | undefined;
  certificateThumbprint?: string | undefined;
  dpopKeyThumbprint?: string | undefined;
  authorizationDetails?: models.AuthorizationDetails$Outbound | undefined;
  resources?: Array<string> | undefined;
  forExternalAttachment?: boolean | undefined;
  jwtAtClaims?: string | undefined;
  acr?: string | undefined;
  authTime?: number | undefined;
  clientEntityIdUsed?: boolean | undefined;
};

/** @internal */
export const AuthTokenCreateApiRequestBody$outboundSchema: z.ZodType<
  AuthTokenCreateApiRequestBody$Outbound,
  z.ZodTypeDef,
  AuthTokenCreateApiRequestBody
> = z.object({
  grantType: models.GrantType$outboundSchema,
  clientId: z.number().int(),
  subject: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  accessTokenDuration: z.number().int().optional(),
  refreshTokenDuration: z.number().int().optional(),
  properties: z.array(models.Property$outboundSchema).optional(),
  clientIdAliasUsed: z.boolean().optional(),
  accessToken: z.string().optional(),
  refreshToken: z.string().optional(),
  accessTokenPersistent: z.boolean().optional(),
  certificateThumbprint: z.string().optional(),
  dpopKeyThumbprint: z.string().optional(),
  authorizationDetails: models.AuthorizationDetails$outboundSchema.optional(),
  resources: z.array(z.string()).optional(),
  forExternalAttachment: z.boolean().optional(),
  jwtAtClaims: z.string().optional(),
  acr: z.string().optional(),
  authTime: z.number().int().optional(),
  clientEntityIdUsed: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenCreateApiRequestBody$ {
  /** @deprecated use `AuthTokenCreateApiRequestBody$inboundSchema` instead. */
  export const inboundSchema = AuthTokenCreateApiRequestBody$inboundSchema;
  /** @deprecated use `AuthTokenCreateApiRequestBody$outboundSchema` instead. */
  export const outboundSchema = AuthTokenCreateApiRequestBody$outboundSchema;
  /** @deprecated use `AuthTokenCreateApiRequestBody$Outbound` instead. */
  export type Outbound = AuthTokenCreateApiRequestBody$Outbound;
}

export function authTokenCreateApiRequestBodyToJSON(
  authTokenCreateApiRequestBody: AuthTokenCreateApiRequestBody,
): string {
  return JSON.stringify(
    AuthTokenCreateApiRequestBody$outboundSchema.parse(
      authTokenCreateApiRequestBody,
    ),
  );
}

export function authTokenCreateApiRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenCreateApiRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokenCreateApiRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenCreateApiRequestBody' from JSON`,
  );
}

/** @internal */
export const AuthTokenCreateApiRequest$inboundSchema: z.ZodType<
  AuthTokenCreateApiRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  serviceId: z.string(),
  RequestBody: z.lazy(() => AuthTokenCreateApiRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type AuthTokenCreateApiRequest$Outbound = {
  serviceId: string;
  RequestBody: AuthTokenCreateApiRequestBody$Outbound;
};

/** @internal */
export const AuthTokenCreateApiRequest$outboundSchema: z.ZodType<
  AuthTokenCreateApiRequest$Outbound,
  z.ZodTypeDef,
  AuthTokenCreateApiRequest
> = z.object({
  serviceId: z.string(),
  requestBody: z.lazy(() => AuthTokenCreateApiRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenCreateApiRequest$ {
  /** @deprecated use `AuthTokenCreateApiRequest$inboundSchema` instead. */
  export const inboundSchema = AuthTokenCreateApiRequest$inboundSchema;
  /** @deprecated use `AuthTokenCreateApiRequest$outboundSchema` instead. */
  export const outboundSchema = AuthTokenCreateApiRequest$outboundSchema;
  /** @deprecated use `AuthTokenCreateApiRequest$Outbound` instead. */
  export type Outbound = AuthTokenCreateApiRequest$Outbound;
}

export function authTokenCreateApiRequestToJSON(
  authTokenCreateApiRequest: AuthTokenCreateApiRequest,
): string {
  return JSON.stringify(
    AuthTokenCreateApiRequest$outboundSchema.parse(authTokenCreateApiRequest),
  );
}

export function authTokenCreateApiRequestFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenCreateApiRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokenCreateApiRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenCreateApiRequest' from JSON`,
  );
}

/** @internal */
export const AuthTokenCreateApiAction$inboundSchema: z.ZodNativeEnum<
  typeof AuthTokenCreateApiAction
> = z.nativeEnum(AuthTokenCreateApiAction);

/** @internal */
export const AuthTokenCreateApiAction$outboundSchema: z.ZodNativeEnum<
  typeof AuthTokenCreateApiAction
> = AuthTokenCreateApiAction$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenCreateApiAction$ {
  /** @deprecated use `AuthTokenCreateApiAction$inboundSchema` instead. */
  export const inboundSchema = AuthTokenCreateApiAction$inboundSchema;
  /** @deprecated use `AuthTokenCreateApiAction$outboundSchema` instead. */
  export const outboundSchema = AuthTokenCreateApiAction$outboundSchema;
}

/** @internal */
export const AuthTokenCreateApiResponse$inboundSchema: z.ZodType<
  AuthTokenCreateApiResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resultCode: z.string().optional(),
  resultMessage: z.string().optional(),
  action: AuthTokenCreateApiAction$inboundSchema.optional(),
  accessToken: z.string().optional(),
  clientId: z.number().int().optional(),
  expiresAt: z.number().int().optional(),
  expiresIn: z.number().int().optional(),
  grantType: z.string().optional(),
  properties: z.array(models.Property$inboundSchema).optional(),
  refreshToken: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  subject: z.string().optional(),
  tokenType: z.string().optional(),
  jwtAccessToken: z.string().optional(),
  authorizationDetails: models.AuthorizationDetails$inboundSchema.optional(),
  forExternalAttachment: z.boolean().optional(),
  tokenId: z.string().optional(),
  refreshTokenScopes: z.array(z.string()).optional(),
});

/** @internal */
export type AuthTokenCreateApiResponse$Outbound = {
  resultCode?: string | undefined;
  resultMessage?: string | undefined;
  action?: string | undefined;
  accessToken?: string | undefined;
  clientId?: number | undefined;
  expiresAt?: number | undefined;
  expiresIn?: number | undefined;
  grantType?: string | undefined;
  properties?: Array<models.Property$Outbound> | undefined;
  refreshToken?: string | undefined;
  scopes?: Array<string> | undefined;
  subject?: string | undefined;
  tokenType?: string | undefined;
  jwtAccessToken?: string | undefined;
  authorizationDetails?: models.AuthorizationDetails$Outbound | undefined;
  forExternalAttachment?: boolean | undefined;
  tokenId?: string | undefined;
  refreshTokenScopes?: Array<string> | undefined;
};

/** @internal */
export const AuthTokenCreateApiResponse$outboundSchema: z.ZodType<
  AuthTokenCreateApiResponse$Outbound,
  z.ZodTypeDef,
  AuthTokenCreateApiResponse
> = z.object({
  resultCode: z.string().optional(),
  resultMessage: z.string().optional(),
  action: AuthTokenCreateApiAction$outboundSchema.optional(),
  accessToken: z.string().optional(),
  clientId: z.number().int().optional(),
  expiresAt: z.number().int().optional(),
  expiresIn: z.number().int().optional(),
  grantType: z.string().optional(),
  properties: z.array(models.Property$outboundSchema).optional(),
  refreshToken: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  subject: z.string().optional(),
  tokenType: z.string().optional(),
  jwtAccessToken: z.string().optional(),
  authorizationDetails: models.AuthorizationDetails$outboundSchema.optional(),
  forExternalAttachment: z.boolean().optional(),
  tokenId: z.string().optional(),
  refreshTokenScopes: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenCreateApiResponse$ {
  /** @deprecated use `AuthTokenCreateApiResponse$inboundSchema` instead. */
  export const inboundSchema = AuthTokenCreateApiResponse$inboundSchema;
  /** @deprecated use `AuthTokenCreateApiResponse$outboundSchema` instead. */
  export const outboundSchema = AuthTokenCreateApiResponse$outboundSchema;
  /** @deprecated use `AuthTokenCreateApiResponse$Outbound` instead. */
  export type Outbound = AuthTokenCreateApiResponse$Outbound;
}

export function authTokenCreateApiResponseToJSON(
  authTokenCreateApiResponse: AuthTokenCreateApiResponse,
): string {
  return JSON.stringify(
    AuthTokenCreateApiResponse$outboundSchema.parse(authTokenCreateApiResponse),
  );
}

export function authTokenCreateApiResponseFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenCreateApiResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokenCreateApiResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenCreateApiResponse' from JSON`,
  );
}
