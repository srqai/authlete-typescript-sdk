/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

export type AuthUserinfoApiFormRequest = {
  /**
   * A service ID.
   */
  serviceId: string;
  userinfoRequest: models.UserinfoRequest;
};

/**
 * The next action that the authorization server implementation should take.
 */
export const AuthUserinfoApiFormAction = {
  InternalServerError: "INTERNAL_SERVER_ERROR",
  BadRequest: "BAD_REQUEST",
  Unauthorized: "UNAUTHORIZED",
  Forbidden: "FORBIDDEN",
  Ok: "OK",
} as const;
/**
 * The next action that the authorization server implementation should take.
 */
export type AuthUserinfoApiFormAction = ClosedEnum<
  typeof AuthUserinfoApiFormAction
>;

/**
 * Successful operation
 */
export type AuthUserinfoApiFormResponse = {
  /**
   * The code which represents the result of the API call.
   */
  resultCode?: string | undefined;
  /**
   * A short message which explains the result of the API call.
   */
  resultMessage?: string | undefined;
  /**
   * The next action that the authorization server implementation should take.
   */
  action?: AuthUserinfoApiFormAction | undefined;
  /**
   * The list of claims that the client application requests to be embedded in the ID token.
   *
   * @remarks
   */
  claims?: Array<string> | undefined;
  /**
   * The ID of the client application which is associated with the access token.
   *
   * @remarks
   */
  clientId?: number | undefined;
  /**
   * The client ID alias when the authorization request for the access token was made.
   *
   * @remarks
   */
  clientIdAlias?: string | undefined;
  /**
   * The flag which indicates whether the client ID alias was used when the authorization
   *
   * @remarks
   * request for the access token was made.
   */
  clientIdAliasUsed?: boolean | undefined;
  /**
   * The content that the authorization server implementation can use as the value of `WWW-Authenticate`
   *
   * @remarks
   * header on errors.
   */
  responseContent?: string | undefined;
  /**
   * The scopes covered by the access token.
   *
   * @remarks
   */
  scopes?: Array<string> | undefined;
  /**
   * The subject (= resource owner's ID).
   *
   * @remarks
   */
  subject?: string | undefined;
  /**
   * The access token that came along with the userinfo request.
   *
   * @remarks
   */
  token?: string | undefined;
  /**
   * The extra properties associated with the access token.
   *
   * @remarks
   */
  properties?: Array<models.Property> | undefined;
  /**
   * The value of the `userinfo` property in the `claims` request parameter or in the `claims` property in an authorization request object.
   *
   * @remarks
   *
   * A client application may request certain claims be embedded in an ID token or in a response from the userInfo endpoint.
   * There are several ways. Including the `claims` request parameter and including the `claims` property in a request object are such examples.
   * In both cases, the value of the `claims` parameter/property is JSON. Its format is described in [5.5. Requesting Claims using the "claims"
   * Request Parameter](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsParameter).
   *
   * The following is an excerpt from the specification. You can find `userinfo` and `id_token` are top-level properties.
   *
   * ```json
   * {
   *   "userinfo":
   *   {
   *     "given_name": { "essential": true },
   *     "nickname": null,
   *     "email": { "essential": true },
   *     "email_verified": { "essential": true },
   *     "picture": null,
   *     "http://example.info/claims/groups": null
   *   },
   *   "id_token":
   *   {
   *     "auth_time": { "essential": true },
   *     "acr": { "values": [ "urn:mace:incommon:iap:silver" ] }
   *   }
   * }
   * ````
   *
   * The value of this property is the value of the `userinfo` property in JSON format.
   * For example, if the JSON above is included in an authorization request, this property holds JSON equivalent to the following.
   *
   * ```json
   * {
   *   "given_name": { "essential": true },
   *   "nickname": null,
   *   "email": { "essential": true },
   *   "email_verified": { "essential": true },
   *   "picture": null,
   *   "http://example.info/claims/groups": null
   * }
   * ```
   *
   * Note that if a request object is given and it contains the `claims` property and if the `claims` request parameter is also given,
   * the value of this property holds the former value.
   */
  userInfoClaims?: string | undefined;
  /**
   * The attributes of this service that the client application belongs to.
   *
   * @remarks
   */
  serviceAttributes?: Array<models.Pair> | undefined;
  /**
   * The attributes of the client.
   *
   * @remarks
   */
  clientAttributes?: Array<models.Pair> | undefined;
  /**
   * the claims that the user has consented for the client application
   *
   * @remarks
   * to know.
   */
  consentedClaims?: Array<string> | undefined;
  /**
   * Get names of claims that are requested indirectly by <i>"transformed
   *
   * @remarks
   * claims"</i>.
   *
   * <p>
   * A client application can request <i>"transformed claims"</i> by adding
   * names of transformed claims in the `claims` request parameter.
   * The following is an example of the `claims` request parameter
   * that requests a predefined transformed claim named `18_or_over`
   * and a transformed claim named `nationality_usa` to be embedded
   * in the response from the userinfo endpoint.
   * </p>
   *
   * ```json
   * {
   *   "transformed_claims": {
   *     "nationality_usa": {
   *       "claim": "nationalities",
   *       "fn": [
   *         [ "eq", "USA" ],
   *         "any"
   *       ]
   *     }
   *   },
   *   "userinfo": {
   *     "::18_or_over": null,
   *     ":nationality_usa": null
   *   }
   * }
   * ```
   *
   * The example above assumes that a transformed claim named `18_or_over`
   * is predefined by the authorization server like below.
   *
   * ```json
   * {
   *   "18_or_over": {
   *     "claim": "birthdate",
   *     "fn": [
   *       "years_ago",
   *       [ "gte", 18 ]
   *     ]
   *   }
   * }
   * ```
   *
   * In the example, the `nationalities` claim is requested indirectly
   * by the `nationality_usa` transformed claim. Likewise, the
   * `birthdate` claim is requested indirectly by the `18_or_over`
   * transformed claim.
   *
   * When the `claims` request parameter of an authorization request is
   * like the example above, this `requestedClaimsForTx` property will
   * hold the following value.
   *
   * ```json
   * [ "birthdate", "nationalities" ]
   * ```
   *
   * It is expected that the authorization server implementation prepares values
   * of the listed claims and passes them as the value of the `claimsForTx`
   * request parameter when it calls the `/api/auth/userinfo/issue` API. The following
   * is an example of the value of the `claimsForTx` request parameter.
   *
   * ```json
   * {
   *   "birthdate": "1970-01-23",
   *   "nationalities": [ "DEU", "USA" ]
   * }
   * ```
   */
  requestedClaimsForTx?: Array<string> | undefined;
  /**
   * Names of verified claims that will be referenced when transformed claims are computed.
   *
   * @remarks
   */
  requestedVerifiedClaimsForTx?: Array<Array<string>> | undefined;
  /**
   * the value of the `transformed_claims` property in the `claims` request
   *
   * @remarks
   * parameter of an authorization request or in the `claims` property in a
   * request object.
   */
  transformedClaims?: string | undefined;
  /**
   * The entity ID of the client.
   *
   * @remarks
   */
  clientEntityId?: string | undefined;
  /**
   * Flag which indicates whether the entity ID of the client was used when the request for the access token was made.
   *
   * @remarks
   */
  clientEntityIdUsed?: boolean | undefined;
  /**
   * The expected nonce value for DPoP proof JWT, which should be used
   *
   * @remarks
   * as the value of the `DPoP-Nonce` HTTP header.
   */
  dpopNonce?: string | undefined;
};

/** @internal */
export const AuthUserinfoApiFormRequest$inboundSchema: z.ZodType<
  AuthUserinfoApiFormRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  serviceId: z.string(),
  UserinfoRequest: models.UserinfoRequest$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "UserinfoRequest": "userinfoRequest",
  });
});

/** @internal */
export type AuthUserinfoApiFormRequest$Outbound = {
  serviceId: string;
  UserinfoRequest: models.UserinfoRequest$Outbound;
};

/** @internal */
export const AuthUserinfoApiFormRequest$outboundSchema: z.ZodType<
  AuthUserinfoApiFormRequest$Outbound,
  z.ZodTypeDef,
  AuthUserinfoApiFormRequest
> = z.object({
  serviceId: z.string(),
  userinfoRequest: models.UserinfoRequest$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    userinfoRequest: "UserinfoRequest",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthUserinfoApiFormRequest$ {
  /** @deprecated use `AuthUserinfoApiFormRequest$inboundSchema` instead. */
  export const inboundSchema = AuthUserinfoApiFormRequest$inboundSchema;
  /** @deprecated use `AuthUserinfoApiFormRequest$outboundSchema` instead. */
  export const outboundSchema = AuthUserinfoApiFormRequest$outboundSchema;
  /** @deprecated use `AuthUserinfoApiFormRequest$Outbound` instead. */
  export type Outbound = AuthUserinfoApiFormRequest$Outbound;
}

export function authUserinfoApiFormRequestToJSON(
  authUserinfoApiFormRequest: AuthUserinfoApiFormRequest,
): string {
  return JSON.stringify(
    AuthUserinfoApiFormRequest$outboundSchema.parse(authUserinfoApiFormRequest),
  );
}

export function authUserinfoApiFormRequestFromJSON(
  jsonString: string,
): SafeParseResult<AuthUserinfoApiFormRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthUserinfoApiFormRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthUserinfoApiFormRequest' from JSON`,
  );
}

/** @internal */
export const AuthUserinfoApiFormAction$inboundSchema: z.ZodNativeEnum<
  typeof AuthUserinfoApiFormAction
> = z.nativeEnum(AuthUserinfoApiFormAction);

/** @internal */
export const AuthUserinfoApiFormAction$outboundSchema: z.ZodNativeEnum<
  typeof AuthUserinfoApiFormAction
> = AuthUserinfoApiFormAction$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthUserinfoApiFormAction$ {
  /** @deprecated use `AuthUserinfoApiFormAction$inboundSchema` instead. */
  export const inboundSchema = AuthUserinfoApiFormAction$inboundSchema;
  /** @deprecated use `AuthUserinfoApiFormAction$outboundSchema` instead. */
  export const outboundSchema = AuthUserinfoApiFormAction$outboundSchema;
}

/** @internal */
export const AuthUserinfoApiFormResponse$inboundSchema: z.ZodType<
  AuthUserinfoApiFormResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resultCode: z.string().optional(),
  resultMessage: z.string().optional(),
  action: AuthUserinfoApiFormAction$inboundSchema.optional(),
  claims: z.array(z.string()).optional(),
  clientId: z.number().int().optional(),
  clientIdAlias: z.string().optional(),
  clientIdAliasUsed: z.boolean().optional(),
  responseContent: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  subject: z.string().optional(),
  token: z.string().optional(),
  properties: z.array(models.Property$inboundSchema).optional(),
  userInfoClaims: z.string().optional(),
  serviceAttributes: z.array(models.Pair$inboundSchema).optional(),
  clientAttributes: z.array(models.Pair$inboundSchema).optional(),
  consentedClaims: z.array(z.string()).optional(),
  requestedClaimsForTx: z.array(z.string()).optional(),
  requestedVerifiedClaimsForTx: z.array(z.array(z.string())).optional(),
  transformedClaims: z.string().optional(),
  clientEntityId: z.string().optional(),
  clientEntityIdUsed: z.boolean().optional(),
  dpopNonce: z.string().optional(),
});

/** @internal */
export type AuthUserinfoApiFormResponse$Outbound = {
  resultCode?: string | undefined;
  resultMessage?: string | undefined;
  action?: string | undefined;
  claims?: Array<string> | undefined;
  clientId?: number | undefined;
  clientIdAlias?: string | undefined;
  clientIdAliasUsed?: boolean | undefined;
  responseContent?: string | undefined;
  scopes?: Array<string> | undefined;
  subject?: string | undefined;
  token?: string | undefined;
  properties?: Array<models.Property$Outbound> | undefined;
  userInfoClaims?: string | undefined;
  serviceAttributes?: Array<models.Pair$Outbound> | undefined;
  clientAttributes?: Array<models.Pair$Outbound> | undefined;
  consentedClaims?: Array<string> | undefined;
  requestedClaimsForTx?: Array<string> | undefined;
  requestedVerifiedClaimsForTx?: Array<Array<string>> | undefined;
  transformedClaims?: string | undefined;
  clientEntityId?: string | undefined;
  clientEntityIdUsed?: boolean | undefined;
  dpopNonce?: string | undefined;
};

/** @internal */
export const AuthUserinfoApiFormResponse$outboundSchema: z.ZodType<
  AuthUserinfoApiFormResponse$Outbound,
  z.ZodTypeDef,
  AuthUserinfoApiFormResponse
> = z.object({
  resultCode: z.string().optional(),
  resultMessage: z.string().optional(),
  action: AuthUserinfoApiFormAction$outboundSchema.optional(),
  claims: z.array(z.string()).optional(),
  clientId: z.number().int().optional(),
  clientIdAlias: z.string().optional(),
  clientIdAliasUsed: z.boolean().optional(),
  responseContent: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  subject: z.string().optional(),
  token: z.string().optional(),
  properties: z.array(models.Property$outboundSchema).optional(),
  userInfoClaims: z.string().optional(),
  serviceAttributes: z.array(models.Pair$outboundSchema).optional(),
  clientAttributes: z.array(models.Pair$outboundSchema).optional(),
  consentedClaims: z.array(z.string()).optional(),
  requestedClaimsForTx: z.array(z.string()).optional(),
  requestedVerifiedClaimsForTx: z.array(z.array(z.string())).optional(),
  transformedClaims: z.string().optional(),
  clientEntityId: z.string().optional(),
  clientEntityIdUsed: z.boolean().optional(),
  dpopNonce: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthUserinfoApiFormResponse$ {
  /** @deprecated use `AuthUserinfoApiFormResponse$inboundSchema` instead. */
  export const inboundSchema = AuthUserinfoApiFormResponse$inboundSchema;
  /** @deprecated use `AuthUserinfoApiFormResponse$outboundSchema` instead. */
  export const outboundSchema = AuthUserinfoApiFormResponse$outboundSchema;
  /** @deprecated use `AuthUserinfoApiFormResponse$Outbound` instead. */
  export type Outbound = AuthUserinfoApiFormResponse$Outbound;
}

export function authUserinfoApiFormResponseToJSON(
  authUserinfoApiFormResponse: AuthUserinfoApiFormResponse,
): string {
  return JSON.stringify(
    AuthUserinfoApiFormResponse$outboundSchema.parse(
      authUserinfoApiFormResponse,
    ),
  );
}

export function authUserinfoApiFormResponseFromJSON(
  jsonString: string,
): SafeParseResult<AuthUserinfoApiFormResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthUserinfoApiFormResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthUserinfoApiFormResponse' from JSON`,
  );
}
