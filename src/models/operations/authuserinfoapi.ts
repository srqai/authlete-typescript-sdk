/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

/**
 * An object containing schema data
 */
export type AuthUserinfoApiRequestBody = {
  /**
   * An access token.
   *
   * @remarks
   */
  token: string;
  /**
   * Client certificate used in the TLS connection established between the client application and the userinfo endpoint.
   *
   * @remarks
   *
   * The value of this request parameter is referred to when the access token given to the userinfo endpoint was bound to
   * a client certificate when it was issued. See [OAuth 2.0 Mutual TLS Client Authentication and Certificate-Bound Access Tokens]
   * (https://datatracker.ietf.org/doc/rfc8705/) for details about the specification of certificate-bound access tokens.
   */
  clientCertificate?: string | undefined;
  /**
   * `DPoP` header presented by the client during the request to the user info endpoint.
   *
   * @remarks
   *
   * The header contains a signed JWT which includes the public key that is paired with the private key used to sign the JWT.
   * See [OAuth 2.0 Demonstration of Proof-of-Possession at the Application Layer (DPoP)](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop)
   * for details.
   */
  dpop?: string | undefined;
  /**
   * HTTP method of the user info request. This field is used to validate the DPoP header.
   *
   * @remarks
   * In normal cases, the value is either `GET` or `POST`.
   */
  htm?: string | undefined;
  /**
   * URL of the user info endpoint. This field is used to validate the DPoP header.
   *
   * @remarks
   *
   * If this parameter is omitted, the `userInfoEndpoint` property of the service is used as the default value.
   * See [OAuth 2.0 Demonstration of Proof-of-Possession at the Application Layer (DPoP)](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop)
   * for details.
   */
  htu?: string | undefined;
  /**
   * The full URL of the userinfo endpoint.
   *
   * @remarks
   */
  uri?: string | undefined;
  /**
   * The HTTP message body of the request, if present.
   *
   * @remarks
   */
  message?: string | undefined;
  /**
   * HTTP headers to be included in processing the signature. If this is a signed request, this must include the
   *
   * @remarks
   * Signature and Signature-Input headers, as well as any additional headers covered by the signature.
   */
  headers?: Array<models.Pair> | undefined;
};

export type AuthUserinfoApiRequest = {
  /**
   * A service ID.
   */
  serviceId: string;
  requestBody: AuthUserinfoApiRequestBody;
};

/**
 * The next action that the authorization server implementation should take.
 */
export const AuthUserinfoApiAction = {
  InternalServerError: "INTERNAL_SERVER_ERROR",
  BadRequest: "BAD_REQUEST",
  Created: "CREATED",
  Unauthorized: "UNAUTHORIZED",
  Forbidden: "FORBIDDEN",
  Json: "JSON",
  Jwt: "JWT",
  Ok: "OK",
} as const;
/**
 * The next action that the authorization server implementation should take.
 */
export type AuthUserinfoApiAction = ClosedEnum<typeof AuthUserinfoApiAction>;

/**
 * An object containing schema data
 */
export type AuthUserinfoApiResponse = {
  /**
   * The code which represents the result of the API call.
   */
  resultCode?: string | undefined;
  /**
   * A short message which explains the result of the API call.
   */
  resultMessage?: string | undefined;
  /**
   * The next action that the authorization server implementation should take.
   */
  action?: AuthUserinfoApiAction | undefined;
  /**
   * The list of claims that the client application requests to be embedded in the ID token.
   *
   * @remarks
   */
  claims?: Array<string> | undefined;
  /**
   * The ID of the client application which is associated with the access token.
   *
   * @remarks
   */
  clientId?: number | undefined;
  /**
   * The client ID alias when the authorization request for the access token was made.
   *
   * @remarks
   */
  clientIdAlias?: string | undefined;
  /**
   * The flag which indicates whether the client ID alias was used when the authorization
   *
   * @remarks
   * request for the access token was made.
   */
  clientIdAliasUsed?: boolean | undefined;
  /**
   * The content that the authorization server implementation can use as the value of `WWW-Authenticate`
   *
   * @remarks
   * header on errors.
   */
  responseContent?: string | undefined;
  /**
   * The scopes covered by the access token.
   *
   * @remarks
   */
  scopes?: Array<string> | undefined;
  /**
   * The subject (= resource owner's ID).
   *
   * @remarks
   */
  subject?: string | undefined;
  /**
   * The access token that came along with the userinfo request.
   *
   * @remarks
   */
  token?: string | undefined;
  /**
   * The extra properties associated with the access token.
   *
   * @remarks
   */
  properties?: Array<models.Property> | undefined;
  /**
   * The value of the `userinfo` property in the `claims` request parameter or in the `claims` property in an authorization request object.
   *
   * @remarks
   *
   * A client application may request certain claims be embedded in an ID token or in a response from the userInfo endpoint.
   * There are several ways. Including the `claims` request parameter and including the `claims` property in a request object are such examples.
   * In both cases, the value of the `claims` parameter/property is JSON. Its format is described in [5.5. Requesting Claims using the "claims"
   * Request Parameter](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsParameter).
   *
   * The following is an excerpt from the specification. You can find `userinfo` and `id_token` are top-level properties.
   *
   * ```json
   * {
   *   "userinfo":
   *   {
   *     "given_name": { "essential": true },
   *     "nickname": null,
   *     "email": { "essential": true },
   *     "email_verified": { "essential": true },
   *     "picture": null,
   *     "http://example.info/claims/groups": null
   *   },
   *   "id_token":
   *   {
   *     "auth_time": { "essential": true },
   *     "acr": { "values": [ "urn:mace:incommon:iap:silver" ] }
   *   }
   * }
   * ````
   *
   * The value of this property is the value of the `userinfo` property in JSON format.
   * For example, if the JSON above is included in an authorization request, this property holds JSON equivalent to the following.
   *
   * ```json
   * {
   *   "given_name": { "essential": true },
   *   "nickname": null,
   *   "email": { "essential": true },
   *   "email_verified": { "essential": true },
   *   "picture": null,
   *   "http://example.info/claims/groups": null
   * }
   * ```
   *
   * Note that if a request object is given and it contains the `claims` property and if the `claims` request parameter is also given,
   * the value of this property holds the former value.
   */
  userInfoClaims?: string | undefined;
  /**
   * The attributes of this service that the client application belongs to.
   *
   * @remarks
   */
  serviceAttributes?: Array<models.Pair> | undefined;
  /**
   * The attributes of the client.
   *
   * @remarks
   */
  clientAttributes?: Array<models.Pair> | undefined;
  /**
   * the claims that the user has consented for the client application
   *
   * @remarks
   * to know.
   */
  consentedClaims?: Array<string> | undefined;
  /**
   * Get names of claims that are requested indirectly by <i>"transformed
   *
   * @remarks
   * claims"</i>.
   *
   * <p>
   * A client application can request <i>"transformed claims"</i> by adding
   * names of transformed claims in the `claims` request parameter.
   * The following is an example of the `claims` request parameter
   * that requests a predefined transformed claim named `18_or_over`
   * and a transformed claim named `nationality_usa` to be embedded
   * in the response from the userinfo endpoint.
   * </p>
   *
   * ```json
   * {
   *   "transformed_claims": {
   *     "nationality_usa": {
   *       "claim": "nationalities",
   *       "fn": [
   *         [ "eq", "USA" ],
   *         "any"
   *       ]
   *     }
   *   },
   *   "userinfo": {
   *     "::18_or_over": null,
   *     ":nationality_usa": null
   *   }
   * }
   * ```
   *
   * The example above assumes that a transformed claim named `18_or_over`
   * is predefined by the authorization server like below.
   *
   * ```json
   * {
   *   "18_or_over": {
   *     "claim": "birthdate",
   *     "fn": [
   *       "years_ago",
   *       [ "gte", 18 ]
   *     ]
   *   }
   * }
   * ```
   *
   * In the example, the `nationalities` claim is requested indirectly
   * by the `nationality_usa` transformed claim. Likewise, the
   * `birthdate` claim is requested indirectly by the `18_or_over`
   * transformed claim.
   *
   * When the `claims` request parameter of an authorization request is
   * like the example above, this `requestedClaimsForTx` property will
   * hold the following value.
   *
   * ```json
   * [ "birthdate", "nationalities" ]
   * ```
   *
   * It is expected that the authorization server implementation prepares values
   * of the listed claims and passes them as the value of the `claimsForTx`
   * request parameter when it calls the `/api/auth/userinfo/issue` API. The following
   * is an example of the value of the `claimsForTx` request parameter.
   *
   * ```json
   * {
   *   "birthdate": "1970-01-23",
   *   "nationalities": [ "DEU", "USA" ]
   * }
   * ```
   */
  requestedClaimsForTx?: Array<string> | undefined;
  /**
   * Names of verified claims that will be referenced when transformed claims are computed.
   *
   * @remarks
   */
  requestedVerifiedClaimsForTx?: Array<Array<string>> | undefined;
  /**
   * the value of the `transformed_claims` property in the `claims` request
   *
   * @remarks
   * parameter of an authorization request or in the `claims` property in a
   * request object.
   */
  transformedClaims?: string | undefined;
  /**
   * The entity ID of the client.
   *
   * @remarks
   */
  clientEntityId?: string | undefined;
  /**
   * Flag which indicates whether the entity ID of the client was used when the request for the access token was made.
   *
   * @remarks
   */
  clientEntityIdUsed?: boolean | undefined;
  /**
   * The expected nonce value for DPoP proof JWT, which should be used
   *
   * @remarks
   * as the value of the `DPoP-Nonce` HTTP header.
   */
  dpopNonce?: string | undefined;
};

/** @internal */
export const AuthUserinfoApiRequestBody$inboundSchema: z.ZodType<
  AuthUserinfoApiRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  clientCertificate: z.string().optional(),
  dpop: z.string().optional(),
  htm: z.string().optional(),
  htu: z.string().optional(),
  uri: z.string().optional(),
  message: z.string().optional(),
  headers: z.array(models.Pair$inboundSchema).optional(),
});

/** @internal */
export type AuthUserinfoApiRequestBody$Outbound = {
  token: string;
  clientCertificate?: string | undefined;
  dpop?: string | undefined;
  htm?: string | undefined;
  htu?: string | undefined;
  uri?: string | undefined;
  message?: string | undefined;
  headers?: Array<models.Pair$Outbound> | undefined;
};

/** @internal */
export const AuthUserinfoApiRequestBody$outboundSchema: z.ZodType<
  AuthUserinfoApiRequestBody$Outbound,
  z.ZodTypeDef,
  AuthUserinfoApiRequestBody
> = z.object({
  token: z.string(),
  clientCertificate: z.string().optional(),
  dpop: z.string().optional(),
  htm: z.string().optional(),
  htu: z.string().optional(),
  uri: z.string().optional(),
  message: z.string().optional(),
  headers: z.array(models.Pair$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthUserinfoApiRequestBody$ {
  /** @deprecated use `AuthUserinfoApiRequestBody$inboundSchema` instead. */
  export const inboundSchema = AuthUserinfoApiRequestBody$inboundSchema;
  /** @deprecated use `AuthUserinfoApiRequestBody$outboundSchema` instead. */
  export const outboundSchema = AuthUserinfoApiRequestBody$outboundSchema;
  /** @deprecated use `AuthUserinfoApiRequestBody$Outbound` instead. */
  export type Outbound = AuthUserinfoApiRequestBody$Outbound;
}

export function authUserinfoApiRequestBodyToJSON(
  authUserinfoApiRequestBody: AuthUserinfoApiRequestBody,
): string {
  return JSON.stringify(
    AuthUserinfoApiRequestBody$outboundSchema.parse(authUserinfoApiRequestBody),
  );
}

export function authUserinfoApiRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<AuthUserinfoApiRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthUserinfoApiRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthUserinfoApiRequestBody' from JSON`,
  );
}

/** @internal */
export const AuthUserinfoApiRequest$inboundSchema: z.ZodType<
  AuthUserinfoApiRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  serviceId: z.string(),
  RequestBody: z.lazy(() => AuthUserinfoApiRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type AuthUserinfoApiRequest$Outbound = {
  serviceId: string;
  RequestBody: AuthUserinfoApiRequestBody$Outbound;
};

/** @internal */
export const AuthUserinfoApiRequest$outboundSchema: z.ZodType<
  AuthUserinfoApiRequest$Outbound,
  z.ZodTypeDef,
  AuthUserinfoApiRequest
> = z.object({
  serviceId: z.string(),
  requestBody: z.lazy(() => AuthUserinfoApiRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthUserinfoApiRequest$ {
  /** @deprecated use `AuthUserinfoApiRequest$inboundSchema` instead. */
  export const inboundSchema = AuthUserinfoApiRequest$inboundSchema;
  /** @deprecated use `AuthUserinfoApiRequest$outboundSchema` instead. */
  export const outboundSchema = AuthUserinfoApiRequest$outboundSchema;
  /** @deprecated use `AuthUserinfoApiRequest$Outbound` instead. */
  export type Outbound = AuthUserinfoApiRequest$Outbound;
}

export function authUserinfoApiRequestToJSON(
  authUserinfoApiRequest: AuthUserinfoApiRequest,
): string {
  return JSON.stringify(
    AuthUserinfoApiRequest$outboundSchema.parse(authUserinfoApiRequest),
  );
}

export function authUserinfoApiRequestFromJSON(
  jsonString: string,
): SafeParseResult<AuthUserinfoApiRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthUserinfoApiRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthUserinfoApiRequest' from JSON`,
  );
}

/** @internal */
export const AuthUserinfoApiAction$inboundSchema: z.ZodNativeEnum<
  typeof AuthUserinfoApiAction
> = z.nativeEnum(AuthUserinfoApiAction);

/** @internal */
export const AuthUserinfoApiAction$outboundSchema: z.ZodNativeEnum<
  typeof AuthUserinfoApiAction
> = AuthUserinfoApiAction$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthUserinfoApiAction$ {
  /** @deprecated use `AuthUserinfoApiAction$inboundSchema` instead. */
  export const inboundSchema = AuthUserinfoApiAction$inboundSchema;
  /** @deprecated use `AuthUserinfoApiAction$outboundSchema` instead. */
  export const outboundSchema = AuthUserinfoApiAction$outboundSchema;
}

/** @internal */
export const AuthUserinfoApiResponse$inboundSchema: z.ZodType<
  AuthUserinfoApiResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resultCode: z.string().optional(),
  resultMessage: z.string().optional(),
  action: AuthUserinfoApiAction$inboundSchema.optional(),
  claims: z.array(z.string()).optional(),
  clientId: z.number().int().optional(),
  clientIdAlias: z.string().optional(),
  clientIdAliasUsed: z.boolean().optional(),
  responseContent: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  subject: z.string().optional(),
  token: z.string().optional(),
  properties: z.array(models.Property$inboundSchema).optional(),
  userInfoClaims: z.string().optional(),
  serviceAttributes: z.array(models.Pair$inboundSchema).optional(),
  clientAttributes: z.array(models.Pair$inboundSchema).optional(),
  consentedClaims: z.array(z.string()).optional(),
  requestedClaimsForTx: z.array(z.string()).optional(),
  requestedVerifiedClaimsForTx: z.array(z.array(z.string())).optional(),
  transformedClaims: z.string().optional(),
  clientEntityId: z.string().optional(),
  clientEntityIdUsed: z.boolean().optional(),
  dpopNonce: z.string().optional(),
});

/** @internal */
export type AuthUserinfoApiResponse$Outbound = {
  resultCode?: string | undefined;
  resultMessage?: string | undefined;
  action?: string | undefined;
  claims?: Array<string> | undefined;
  clientId?: number | undefined;
  clientIdAlias?: string | undefined;
  clientIdAliasUsed?: boolean | undefined;
  responseContent?: string | undefined;
  scopes?: Array<string> | undefined;
  subject?: string | undefined;
  token?: string | undefined;
  properties?: Array<models.Property$Outbound> | undefined;
  userInfoClaims?: string | undefined;
  serviceAttributes?: Array<models.Pair$Outbound> | undefined;
  clientAttributes?: Array<models.Pair$Outbound> | undefined;
  consentedClaims?: Array<string> | undefined;
  requestedClaimsForTx?: Array<string> | undefined;
  requestedVerifiedClaimsForTx?: Array<Array<string>> | undefined;
  transformedClaims?: string | undefined;
  clientEntityId?: string | undefined;
  clientEntityIdUsed?: boolean | undefined;
  dpopNonce?: string | undefined;
};

/** @internal */
export const AuthUserinfoApiResponse$outboundSchema: z.ZodType<
  AuthUserinfoApiResponse$Outbound,
  z.ZodTypeDef,
  AuthUserinfoApiResponse
> = z.object({
  resultCode: z.string().optional(),
  resultMessage: z.string().optional(),
  action: AuthUserinfoApiAction$outboundSchema.optional(),
  claims: z.array(z.string()).optional(),
  clientId: z.number().int().optional(),
  clientIdAlias: z.string().optional(),
  clientIdAliasUsed: z.boolean().optional(),
  responseContent: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  subject: z.string().optional(),
  token: z.string().optional(),
  properties: z.array(models.Property$outboundSchema).optional(),
  userInfoClaims: z.string().optional(),
  serviceAttributes: z.array(models.Pair$outboundSchema).optional(),
  clientAttributes: z.array(models.Pair$outboundSchema).optional(),
  consentedClaims: z.array(z.string()).optional(),
  requestedClaimsForTx: z.array(z.string()).optional(),
  requestedVerifiedClaimsForTx: z.array(z.array(z.string())).optional(),
  transformedClaims: z.string().optional(),
  clientEntityId: z.string().optional(),
  clientEntityIdUsed: z.boolean().optional(),
  dpopNonce: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthUserinfoApiResponse$ {
  /** @deprecated use `AuthUserinfoApiResponse$inboundSchema` instead. */
  export const inboundSchema = AuthUserinfoApiResponse$inboundSchema;
  /** @deprecated use `AuthUserinfoApiResponse$outboundSchema` instead. */
  export const outboundSchema = AuthUserinfoApiResponse$outboundSchema;
  /** @deprecated use `AuthUserinfoApiResponse$Outbound` instead. */
  export type Outbound = AuthUserinfoApiResponse$Outbound;
}

export function authUserinfoApiResponseToJSON(
  authUserinfoApiResponse: AuthUserinfoApiResponse,
): string {
  return JSON.stringify(
    AuthUserinfoApiResponse$outboundSchema.parse(authUserinfoApiResponse),
  );
}

export function authUserinfoApiResponseFromJSON(
  jsonString: string,
): SafeParseResult<AuthUserinfoApiResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthUserinfoApiResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthUserinfoApiResponse' from JSON`,
  );
}
