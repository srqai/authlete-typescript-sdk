/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

/**
 * The result of the end-user authentication and authorization. One of the following. Details are
 *
 * @remarks
 * described in the description.
 */
export const BackchannelAuthenticationCompleteApiResult = {
  TransactionFailed: "TRANSACTION_FAILED",
  AccessDenied: "ACCESS_DENIED",
  Authorized: "AUTHORIZED",
} as const;
/**
 * The result of the end-user authentication and authorization. One of the following. Details are
 *
 * @remarks
 * described in the description.
 */
export type BackchannelAuthenticationCompleteApiResult = ClosedEnum<
  typeof BackchannelAuthenticationCompleteApiResult
>;

export type BackchannelAuthenticationCompleteApiRequestBody = {
  /**
   * The ticket issued by Authlete's `/backchannel/authentication` API.
   *
   * @remarks
   */
  ticket: string;
  /**
   * The result of the end-user authentication and authorization. One of the following. Details are
   *
   * @remarks
   * described in the description.
   */
  result: BackchannelAuthenticationCompleteApiResult;
  /**
   * The subject (= unique identifier) of the end-user.
   *
   * @remarks
   */
  subject: string;
  /**
   * The value of the sub claim that should be used in the ID token.
   *
   * @remarks
   */
  sub?: string | undefined;
  /**
   * The time at which the end-user was authenticated. Its value is the number of seconds from `1970-01-01`.
   *
   * @remarks
   */
  authTime?: number | undefined;
  /**
   * The reference of the authentication context class which the end-user authentication satisfied.
   *
   * @remarks
   */
  acr?: string | undefined;
  /**
   * Additional claims which will be embedded in the ID token.
   *
   * @remarks
   */
  claims?: string | undefined;
  /**
   * The extra properties associated with the access token.
   *
   * @remarks
   */
  properties?: Array<models.Property> | undefined;
  /**
   * Scopes to replace the scopes specified in the original backchannel authentication request with.
   *
   * @remarks
   * When nothing is specified for this parameter, replacement is not performed.
   */
  scopes?: Array<string> | undefined;
  /**
   * JSON that represents additional JWS header parameters for ID tokens.
   *
   * @remarks
   */
  idtHeaderParams?: string | undefined;
  /**
   * The description of the error. If this optional request parameter is given, its value is used as
   *
   * @remarks
   * the value of the `error_description` property, but it is used only when the result is not `AUTHORIZED`.
   * To comply with the specification strictly, the description must not include characters outside
   * the set `%x20-21 / %x23-5B / %x5D-7E`.
   */
  errorDescription?: string | undefined;
  /**
   * The URI of a document which describes the error in detail. This corresponds to the `error_uri`
   *
   * @remarks
   * property in the response to the client.
   */
  errorUri?: string | undefined;
  /**
   * the claims that the user has consented for the client application
   *
   * @remarks
   * to know.
   */
  consentedClaims?: Array<string> | undefined;
  /**
   * Additional claims that are added to the payload part of the JWT access token.
   *
   * @remarks
   */
  jwtAtClaims?: string | undefined;
  /**
   * The representation of an access token that may be issued as a result of the Authlete API call.
   *
   * @remarks
   */
  accessToken?: string | undefined;
};

export type BackchannelAuthenticationCompleteApiRequest = {
  /**
   * A service ID.
   */
  serviceId: string;
  requestBody: BackchannelAuthenticationCompleteApiRequestBody;
};

/**
 * The next action that the authorization server implementation should take.
 *
 * @remarks
 */
export const BackchannelAuthenticationCompleteApiAction = {
  ServerError: "SERVER_ERROR",
  NoAction: "NO_ACTION",
  Notification: "NOTIFICATION",
} as const;
/**
 * The next action that the authorization server implementation should take.
 *
 * @remarks
 */
export type BackchannelAuthenticationCompleteApiAction = ClosedEnum<
  typeof BackchannelAuthenticationCompleteApiAction
>;

/**
 * Successful operation
 */
export type BackchannelAuthenticationCompleteApiResponse = {
  /**
   * The code which represents the result of the API call.
   */
  resultCode?: string | undefined;
  /**
   * A short message which explains the result of the API call.
   */
  resultMessage?: string | undefined;
  /**
   * The next action that the authorization server implementation should take.
   *
   * @remarks
   */
  action?: BackchannelAuthenticationCompleteApiAction | undefined;
  /**
   * The content that the authorization server implementation is to return to the client
   *
   * @remarks
   * application. Its format varies depending on the value of `action` parameter.
   */
  responseContent?: string | undefined;
  /**
   * The client ID of the client application that has made the backchannel authentication
   *
   * @remarks
   * request.
   */
  clientId?: number | undefined;
  /**
   * The client ID alias of the client application that has made the backchannel authentication
   *
   * @remarks
   * request.
   */
  clientIdAlias?: string | undefined;
  /**
   * `true` if the value of the client_id request parameter included in the backchannel
   *
   * @remarks
   * authentication request is the client ID alias. `false` if the value is the original
   * numeric client ID.
   */
  clientIdAliasUsed?: boolean | undefined;
  /**
   * The name of the client application which has made the backchannel authentication request.
   *
   * @remarks
   */
  clientName?: string | undefined;
  deliveryMode?: models.DeliveryMode | undefined;
  /**
   * The client notification endpoint to which a notification needs to be sent. This corresponds
   *
   * @remarks
   * to the `client_notification_endpoint` metadata of the client application.
   */
  clientNotificationEndpoint?: string | undefined;
  /**
   * The client notification token which needs to be embedded as a Bearer token in the Authorization
   *
   * @remarks
   * header in the notification. This is the value of the `client_notification_token` request
   * parameter included in the backchannel authentication request.
   */
  clientNotificationToken?: string | undefined;
  /**
   * The newly issued authentication request ID.
   *
   * @remarks
   */
  authReqId?: string | undefined;
  /**
   * The issued access token.
   *
   * @remarks
   */
  accessToken?: string | undefined;
  /**
   * The issued refresh token.
   *
   * @remarks
   */
  refreshToken?: string | undefined;
  /**
   * The issued ID token.
   *
   * @remarks
   */
  idToken?: string | undefined;
  /**
   * The duration of the access token in seconds.
   *
   * @remarks
   */
  accessTokenDuration?: number | undefined;
  /**
   * The duration of the refresh token in seconds.
   *
   * @remarks
   */
  refreshTokenDuration?: number | undefined;
  /**
   * The duration of the ID token in seconds.
   *
   * @remarks
   */
  idTokenDuration?: number | undefined;
  /**
   * The issued access token in JWT format.
   *
   * @remarks
   */
  jwtAccessToken?: string | undefined;
  /**
   * The resources specified by the `resource` request parameters or by the `resource` property
   *
   * @remarks
   * in the request object. If both are given, the values in the request object should be
   * set. See "Resource Indicators for OAuth 2.0" for details.
   */
  resources?: Array<string> | undefined;
  /**
   * The authorization details. This represents the value of the `authorization_details`
   *
   * @remarks
   * request parameter in the preceding device authorization request which is defined in
   * "OAuth 2.0 Rich Authorization Requests".
   */
  authorizationDetails?: models.AuthorizationDetails | undefined;
  /**
   * The attributes of this service that the client application belongs to.
   *
   * @remarks
   */
  serviceAttributes?: Array<models.Pair> | undefined;
  /**
   * The attributes of the client.
   *
   * @remarks
   */
  clientAttributes?: Array<models.Pair> | undefined;
  /**
   * the value of the `grant_id` request parameter of the device authorization request.
   *
   * @remarks
   *
   * The `grant_id` request parameter is defined in
   * [Grant Management for OAuth 2.0](https://openid.net/specs/fapi-grant-management.html)
   * , which is supported by Authlete 2.3 and newer versions.
   */
  grantId?: string | undefined;
  /**
   * The entity ID of the client.
   *
   * @remarks
   */
  clientEntityId?: string | undefined;
  /**
   * Flag which indicates whether the entity ID of the client was used when the request for the access token was made.
   *
   * @remarks
   */
  clientEntityIdUsed?: boolean | undefined;
};

/** @internal */
export const BackchannelAuthenticationCompleteApiResult$inboundSchema:
  z.ZodNativeEnum<typeof BackchannelAuthenticationCompleteApiResult> = z
    .nativeEnum(BackchannelAuthenticationCompleteApiResult);

/** @internal */
export const BackchannelAuthenticationCompleteApiResult$outboundSchema:
  z.ZodNativeEnum<typeof BackchannelAuthenticationCompleteApiResult> =
    BackchannelAuthenticationCompleteApiResult$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackchannelAuthenticationCompleteApiResult$ {
  /** @deprecated use `BackchannelAuthenticationCompleteApiResult$inboundSchema` instead. */
  export const inboundSchema =
    BackchannelAuthenticationCompleteApiResult$inboundSchema;
  /** @deprecated use `BackchannelAuthenticationCompleteApiResult$outboundSchema` instead. */
  export const outboundSchema =
    BackchannelAuthenticationCompleteApiResult$outboundSchema;
}

/** @internal */
export const BackchannelAuthenticationCompleteApiRequestBody$inboundSchema:
  z.ZodType<
    BackchannelAuthenticationCompleteApiRequestBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    ticket: z.string(),
    result: BackchannelAuthenticationCompleteApiResult$inboundSchema,
    subject: z.string(),
    sub: z.string().optional(),
    authTime: z.number().int().optional(),
    acr: z.string().optional(),
    claims: z.string().optional(),
    properties: z.array(models.Property$inboundSchema).optional(),
    scopes: z.array(z.string()).optional(),
    idtHeaderParams: z.string().optional(),
    errorDescription: z.string().optional(),
    errorUri: z.string().optional(),
    consentedClaims: z.array(z.string()).optional(),
    jwtAtClaims: z.string().optional(),
    accessToken: z.string().optional(),
  });

/** @internal */
export type BackchannelAuthenticationCompleteApiRequestBody$Outbound = {
  ticket: string;
  result: string;
  subject: string;
  sub?: string | undefined;
  authTime?: number | undefined;
  acr?: string | undefined;
  claims?: string | undefined;
  properties?: Array<models.Property$Outbound> | undefined;
  scopes?: Array<string> | undefined;
  idtHeaderParams?: string | undefined;
  errorDescription?: string | undefined;
  errorUri?: string | undefined;
  consentedClaims?: Array<string> | undefined;
  jwtAtClaims?: string | undefined;
  accessToken?: string | undefined;
};

/** @internal */
export const BackchannelAuthenticationCompleteApiRequestBody$outboundSchema:
  z.ZodType<
    BackchannelAuthenticationCompleteApiRequestBody$Outbound,
    z.ZodTypeDef,
    BackchannelAuthenticationCompleteApiRequestBody
  > = z.object({
    ticket: z.string(),
    result: BackchannelAuthenticationCompleteApiResult$outboundSchema,
    subject: z.string(),
    sub: z.string().optional(),
    authTime: z.number().int().optional(),
    acr: z.string().optional(),
    claims: z.string().optional(),
    properties: z.array(models.Property$outboundSchema).optional(),
    scopes: z.array(z.string()).optional(),
    idtHeaderParams: z.string().optional(),
    errorDescription: z.string().optional(),
    errorUri: z.string().optional(),
    consentedClaims: z.array(z.string()).optional(),
    jwtAtClaims: z.string().optional(),
    accessToken: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackchannelAuthenticationCompleteApiRequestBody$ {
  /** @deprecated use `BackchannelAuthenticationCompleteApiRequestBody$inboundSchema` instead. */
  export const inboundSchema =
    BackchannelAuthenticationCompleteApiRequestBody$inboundSchema;
  /** @deprecated use `BackchannelAuthenticationCompleteApiRequestBody$outboundSchema` instead. */
  export const outboundSchema =
    BackchannelAuthenticationCompleteApiRequestBody$outboundSchema;
  /** @deprecated use `BackchannelAuthenticationCompleteApiRequestBody$Outbound` instead. */
  export type Outbound =
    BackchannelAuthenticationCompleteApiRequestBody$Outbound;
}

export function backchannelAuthenticationCompleteApiRequestBodyToJSON(
  backchannelAuthenticationCompleteApiRequestBody:
    BackchannelAuthenticationCompleteApiRequestBody,
): string {
  return JSON.stringify(
    BackchannelAuthenticationCompleteApiRequestBody$outboundSchema.parse(
      backchannelAuthenticationCompleteApiRequestBody,
    ),
  );
}

export function backchannelAuthenticationCompleteApiRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  BackchannelAuthenticationCompleteApiRequestBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      BackchannelAuthenticationCompleteApiRequestBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'BackchannelAuthenticationCompleteApiRequestBody' from JSON`,
  );
}

/** @internal */
export const BackchannelAuthenticationCompleteApiRequest$inboundSchema:
  z.ZodType<
    BackchannelAuthenticationCompleteApiRequest,
    z.ZodTypeDef,
    unknown
  > = z.object({
    serviceId: z.string(),
    RequestBody: z.lazy(() =>
      BackchannelAuthenticationCompleteApiRequestBody$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "RequestBody": "requestBody",
    });
  });

/** @internal */
export type BackchannelAuthenticationCompleteApiRequest$Outbound = {
  serviceId: string;
  RequestBody: BackchannelAuthenticationCompleteApiRequestBody$Outbound;
};

/** @internal */
export const BackchannelAuthenticationCompleteApiRequest$outboundSchema:
  z.ZodType<
    BackchannelAuthenticationCompleteApiRequest$Outbound,
    z.ZodTypeDef,
    BackchannelAuthenticationCompleteApiRequest
  > = z.object({
    serviceId: z.string(),
    requestBody: z.lazy(() =>
      BackchannelAuthenticationCompleteApiRequestBody$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      requestBody: "RequestBody",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackchannelAuthenticationCompleteApiRequest$ {
  /** @deprecated use `BackchannelAuthenticationCompleteApiRequest$inboundSchema` instead. */
  export const inboundSchema =
    BackchannelAuthenticationCompleteApiRequest$inboundSchema;
  /** @deprecated use `BackchannelAuthenticationCompleteApiRequest$outboundSchema` instead. */
  export const outboundSchema =
    BackchannelAuthenticationCompleteApiRequest$outboundSchema;
  /** @deprecated use `BackchannelAuthenticationCompleteApiRequest$Outbound` instead. */
  export type Outbound = BackchannelAuthenticationCompleteApiRequest$Outbound;
}

export function backchannelAuthenticationCompleteApiRequestToJSON(
  backchannelAuthenticationCompleteApiRequest:
    BackchannelAuthenticationCompleteApiRequest,
): string {
  return JSON.stringify(
    BackchannelAuthenticationCompleteApiRequest$outboundSchema.parse(
      backchannelAuthenticationCompleteApiRequest,
    ),
  );
}

export function backchannelAuthenticationCompleteApiRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  BackchannelAuthenticationCompleteApiRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      BackchannelAuthenticationCompleteApiRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'BackchannelAuthenticationCompleteApiRequest' from JSON`,
  );
}

/** @internal */
export const BackchannelAuthenticationCompleteApiAction$inboundSchema:
  z.ZodNativeEnum<typeof BackchannelAuthenticationCompleteApiAction> = z
    .nativeEnum(BackchannelAuthenticationCompleteApiAction);

/** @internal */
export const BackchannelAuthenticationCompleteApiAction$outboundSchema:
  z.ZodNativeEnum<typeof BackchannelAuthenticationCompleteApiAction> =
    BackchannelAuthenticationCompleteApiAction$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackchannelAuthenticationCompleteApiAction$ {
  /** @deprecated use `BackchannelAuthenticationCompleteApiAction$inboundSchema` instead. */
  export const inboundSchema =
    BackchannelAuthenticationCompleteApiAction$inboundSchema;
  /** @deprecated use `BackchannelAuthenticationCompleteApiAction$outboundSchema` instead. */
  export const outboundSchema =
    BackchannelAuthenticationCompleteApiAction$outboundSchema;
}

/** @internal */
export const BackchannelAuthenticationCompleteApiResponse$inboundSchema:
  z.ZodType<
    BackchannelAuthenticationCompleteApiResponse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    resultCode: z.string().optional(),
    resultMessage: z.string().optional(),
    action: BackchannelAuthenticationCompleteApiAction$inboundSchema.optional(),
    responseContent: z.string().optional(),
    clientId: z.number().int().optional(),
    clientIdAlias: z.string().optional(),
    clientIdAliasUsed: z.boolean().optional(),
    clientName: z.string().optional(),
    deliveryMode: models.DeliveryMode$inboundSchema.optional(),
    clientNotificationEndpoint: z.string().optional(),
    clientNotificationToken: z.string().optional(),
    authReqId: z.string().optional(),
    accessToken: z.string().optional(),
    refreshToken: z.string().optional(),
    idToken: z.string().optional(),
    accessTokenDuration: z.number().int().optional(),
    refreshTokenDuration: z.number().int().optional(),
    idTokenDuration: z.number().int().optional(),
    jwtAccessToken: z.string().optional(),
    resources: z.array(z.string()).optional(),
    authorizationDetails: models.AuthorizationDetails$inboundSchema.optional(),
    serviceAttributes: z.array(models.Pair$inboundSchema).optional(),
    clientAttributes: z.array(models.Pair$inboundSchema).optional(),
    grantId: z.string().optional(),
    clientEntityId: z.string().optional(),
    clientEntityIdUsed: z.boolean().optional(),
  });

/** @internal */
export type BackchannelAuthenticationCompleteApiResponse$Outbound = {
  resultCode?: string | undefined;
  resultMessage?: string | undefined;
  action?: string | undefined;
  responseContent?: string | undefined;
  clientId?: number | undefined;
  clientIdAlias?: string | undefined;
  clientIdAliasUsed?: boolean | undefined;
  clientName?: string | undefined;
  deliveryMode?: string | undefined;
  clientNotificationEndpoint?: string | undefined;
  clientNotificationToken?: string | undefined;
  authReqId?: string | undefined;
  accessToken?: string | undefined;
  refreshToken?: string | undefined;
  idToken?: string | undefined;
  accessTokenDuration?: number | undefined;
  refreshTokenDuration?: number | undefined;
  idTokenDuration?: number | undefined;
  jwtAccessToken?: string | undefined;
  resources?: Array<string> | undefined;
  authorizationDetails?: models.AuthorizationDetails$Outbound | undefined;
  serviceAttributes?: Array<models.Pair$Outbound> | undefined;
  clientAttributes?: Array<models.Pair$Outbound> | undefined;
  grantId?: string | undefined;
  clientEntityId?: string | undefined;
  clientEntityIdUsed?: boolean | undefined;
};

/** @internal */
export const BackchannelAuthenticationCompleteApiResponse$outboundSchema:
  z.ZodType<
    BackchannelAuthenticationCompleteApiResponse$Outbound,
    z.ZodTypeDef,
    BackchannelAuthenticationCompleteApiResponse
  > = z.object({
    resultCode: z.string().optional(),
    resultMessage: z.string().optional(),
    action: BackchannelAuthenticationCompleteApiAction$outboundSchema
      .optional(),
    responseContent: z.string().optional(),
    clientId: z.number().int().optional(),
    clientIdAlias: z.string().optional(),
    clientIdAliasUsed: z.boolean().optional(),
    clientName: z.string().optional(),
    deliveryMode: models.DeliveryMode$outboundSchema.optional(),
    clientNotificationEndpoint: z.string().optional(),
    clientNotificationToken: z.string().optional(),
    authReqId: z.string().optional(),
    accessToken: z.string().optional(),
    refreshToken: z.string().optional(),
    idToken: z.string().optional(),
    accessTokenDuration: z.number().int().optional(),
    refreshTokenDuration: z.number().int().optional(),
    idTokenDuration: z.number().int().optional(),
    jwtAccessToken: z.string().optional(),
    resources: z.array(z.string()).optional(),
    authorizationDetails: models.AuthorizationDetails$outboundSchema.optional(),
    serviceAttributes: z.array(models.Pair$outboundSchema).optional(),
    clientAttributes: z.array(models.Pair$outboundSchema).optional(),
    grantId: z.string().optional(),
    clientEntityId: z.string().optional(),
    clientEntityIdUsed: z.boolean().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackchannelAuthenticationCompleteApiResponse$ {
  /** @deprecated use `BackchannelAuthenticationCompleteApiResponse$inboundSchema` instead. */
  export const inboundSchema =
    BackchannelAuthenticationCompleteApiResponse$inboundSchema;
  /** @deprecated use `BackchannelAuthenticationCompleteApiResponse$outboundSchema` instead. */
  export const outboundSchema =
    BackchannelAuthenticationCompleteApiResponse$outboundSchema;
  /** @deprecated use `BackchannelAuthenticationCompleteApiResponse$Outbound` instead. */
  export type Outbound = BackchannelAuthenticationCompleteApiResponse$Outbound;
}

export function backchannelAuthenticationCompleteApiResponseToJSON(
  backchannelAuthenticationCompleteApiResponse:
    BackchannelAuthenticationCompleteApiResponse,
): string {
  return JSON.stringify(
    BackchannelAuthenticationCompleteApiResponse$outboundSchema.parse(
      backchannelAuthenticationCompleteApiResponse,
    ),
  );
}

export function backchannelAuthenticationCompleteApiResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  BackchannelAuthenticationCompleteApiResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      BackchannelAuthenticationCompleteApiResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'BackchannelAuthenticationCompleteApiResponse' from JSON`,
  );
}
